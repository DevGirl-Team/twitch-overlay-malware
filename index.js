require("dotenv").config();

const express = require("express");
const path = require("path");
const fs = require("fs");
const app = express();

const http = require("http");
const server = http.createServer(app);
const { Server } = require("socket.io");
const WebSocket = require("ws");
const fetch = require("node-fetch");

let ws;
let sessionId;

const io = new Server(server);

const closeCodes = {
  4000: "Internal Server Error",
  4001: "Client sent inbound traffic",
  4002: "Client failed ping-pong",
  4003: "Connection unused",
  4004: "Reconnect grace time expired",
  4005: "Network Timeout",
  4006: "Network error",
  4007: "Invalid Reconnect",
};

const customRewardsToCreate = [
  {
    title: "ðŸ˜ˆ Invade (1px) ðŸ˜ˆ",
    cost: 10,
  },
  {
    title: "ðŸ˜ˆ Invade (10px) ðŸ˜ˆ",
    cost: 100,
  },
  {
    title: "ðŸ˜ˆ Invade (100px) ðŸ˜ˆ",
    cost: 1000,
  },
];

//channel:read:hype_train
//channel:manage:redemptions

// https://github.com/BarryCarlyon/twitch_misc/tree/main/channel_points
const client_config = JSON.parse(
  fs.readFileSync(path.join(__dirname, "jsons", "config_client.json"))
);
const account_config = JSON.parse(
  fs.readFileSync(path.join(__dirname, "jsons", "config_user.json"))
);
let rewardsConfig = JSON.parse(
  fs.readFileSync(path.join(__dirname, "jsons", "config_rewards.json"))
);

async function entry() {
  // If not token, first auth with the URL /auth
  if (!account_config.access_token) {
    console.error("First go on localhost:3000/auth to authorize the app");
    return false;
  }

  // See if the access_token is still valid
  console.info("Check validity of access_token");
  let resp = await fetch("https://id.twitch.tv/oauth2/validate", {
    method: "GET",
    headers: {
      Authorization: `Bearer ${account_config.access_token}`,
      Accept: "application/json",
    },
  });

  // If access_token isn't valid anymore, regenerate it
  if (resp.status != 200) {
    console.info("access_token not valid, regenerate it");
    regenerate();
    return;
  }

  return true;
}
async function regenerate() {
  let url = new URL("https://id.twitch.tv/oauth2/token");
  url.search = new URLSearchParams([
    ["grant_type", "refresh_token"],
    ["client_id", client_config.client_id],
    ["client_secret", client_config.client_secret],
    ["refresh_token", client_config.refresh_token],
  ]).toString();

  let resp = await fetch(url, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "x-www-form-urlencoded",
    },
  });
  if (resp.status != 200) {
    console.error("Error", resp.status, await resp.text());
    return;
  }
  let body = await resp.json();

  for (var k in body) {
    account_config[k] = body[k];
  }

  fs.writeFileSync(
    path.join(__dirname, "jsons", "config_user.json"),
    JSON.stringify(account_config, null, 4)
  );
}

const twitchFetchHeaders = {
  Authorization: `Bearer ${account_config.access_token}`,
  "Client-ID": client_config.client_id,
  "Content-Type": "application/json",
};

async function subscriptionSub(type) {
  return await fetch(
    "https://api.twitch.tv/helix/eventsub/subscriptions",
    {
      method: "POST",
      headers: twitchFetchHeaders,
      body: JSON.stringify({
        type: type,
        version: "1",
        condition: {
          broadcaster_user_id: "510641053",
        },
        transport: {
          method: "websocket",
          session_id: sessionId,
        },
      }),
    }
  );
}

async function customRewardsSub(id, cost) {
  return await fetch(
    `https://api.twitch.tv/helix/channel_points/custom_rewards?broadcaster_id=510641053&id=${id}`,
    {
      method: "PATCH",
      body: JSON.stringify({
        cost: cost / 2,
      }),
      headers: twitchFetchHeaders,
    }
  );
}

async function connect() {
  if (!(await entry())) return;

  // ws = new WebSocket("ws://localhost:8080/ws");
  ws = new WebSocket("wss://eventsub.wss.twitch.tv/ws");
  ws.on("open", () => {
    console.log(`Opened Connection to Twitch`);
  });

  ws.on("error", (error) => {
    console.error("ERR:  " + JSON.stringify(error) + "\n");
  });

  ws.on("message", async (event) => {
    const eventData = JSON.parse(event.toString());
    let { metadata, payload } = eventData;
    let { message_type } = metadata;
    console.log(message_type);

    switch (message_type) {
      /* WELCOME MESSAGE */
      case "session_welcome":
        sessionId = payload.session.id;
        // Subscription to Channel Point Redeem Event
        const subChannelPointGetterRes = await subscriptionSub("channel.channel_points_custom_reward_redemption.add");
        const subChannelPointGetterData = await subChannelPointGetterRes.json();

        // Subscription to Sub Event
        const subChannelSubRes = await subscriptionSub("channel.subscribe");
        const subChannelSubData = await subChannelSubRes.json();

        // Subscription to Sub Event
        const subBitsSubRes = await subscriptionSub("channel.cheer");
        const subBitsSubData = await subBitsSubRes.json();

        // Subscription to beginning Hype Train Event
        const subBeginHypeTrainRes = await subscriptionSub("channel.hype_train.begin");
        const subBeginHypeTrainData = await subBeginHypeTrainRes.json();

        // Subscription to ending Hype Train Event
        const subEndHypeTrainRes = await subscriptionSub("channel.hype_train.end");
        const subEndHypeTrainData = await subEndHypeTrainRes.json();

        break;

      case "session_keepalive":
        console.log(`Recv KeepAlive - ${message_type}`);
        // this.emit("session_keepalive");
        break;

      case "notification":
        let { subscription, event } = payload;
        let { type } = subscription;
        console.log(type);
        switch (type) {
          case "channel.channel_points_custom_reward_redemption.add":
            if (event.reward.title === "ðŸ˜ˆ Invade (1px) ðŸ˜ˆ") {
              // Emit with Socket IO to client side
              io.emit("channel-point", 1);
            }
            if (event.reward.title === "ðŸ˜ˆ Invade (10px) ðŸ˜ˆ") {
              // Emit with Socket IO to client side
              io.emit("channel-point", 10);
            }
            if (event.reward.title === "ðŸ˜ˆ Invade (100px) ðŸ˜ˆ") {
              // Emit with Socket IO to client side
              io.emit("channel-point", 100);
            }
            break;
          case "channel.subscribe":
            if (event.tier === "1000") io.emit("sub", 10);
            else if (event.tier === "2000") io.emit("sub", 30);
            else if (event.tier === "3000") io.emit("sub", 90);
            break;

          case "channel.cheer":
            // return the greater integer
            io.emit("cheer", Math.ceil(event.bits / 10));
            break;

          case "channel.hype_train.begin":
            rewardsConfig.forEach(async ({ id, cost }) => {
              const editReward = await customRewardsSub(id, cost / 4);
              console.log(await editReward.json());
            });
            break;
          case "channel.hype_train.end":
            rewardsConfig.forEach(async ({ id, cost }) => {
              const editReward = await customRewardsSub(id, cost);
              console.log(await editReward.json());
            });
            break;
        }

        break;
    }
  });

  ws.on("close", (close) => {
    console.log("EventSub close", close);
    console.log(`Connection Closed: ${close} Reason - ${closeCodes[close]}`);
  });
}

connect();

/* SOCKETIO */
io.on("connection", (socket) => {
  // console.log("a user connected");
});

app.get("/", function (req, res) {
  res.sendFile(path.join(__dirname, "/index.html"));
});
app.get("/auth", function (req, res) {
  // res.sendFile(path.join(__dirname, "/auth.html"));
  res.send(`
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Malware auth</title>
      </head>
      <body>
        <a href="
          https://id.twitch.tv/oauth2/authorize?response_type=code&client_id=${client_config.client_id}&redirect_uri=http://localhost:3000/auth/redirect&scope=channel%3Aread%3Aredemptions+channel%3Amanage%3Aredemptions+channel%3Aread%3Ahype_train+channel%3Aread%3Asubscriptions
        ">Twitch Auth</a>
      </body>
    </html>
  `);
});

app.get("/auth/redirect", async function (req, res) {
  let url = new URL("https://id.twitch.tv/oauth2/token");
  url.search = new URLSearchParams([
    ["grant_type", "authorization_code"],
    ["client_id", client_config.client_id],
    ["client_secret", client_config.client_secret],
    ["redirect_uri", "http://localhost:3000/auth/redirect"],
    ["code", req.query.code],
    ["scope", req.query.scope],
  ]).toString();

  let resp = await fetch(url, {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "x-www-form-urlencoded",
    },
  });
  if (resp.status != 200) {
    console.error("Error", resp.status, await resp.text());
    return;
  }
  let body = await resp.json();

  // Get the ids
  for (var k in body) {
    account_config[k] = body[k];
  }

  // Write the ids in config file
  fs.writeFileSync(
    path.join(__dirname, "jsons", "config_user.json"),
    JSON.stringify(account_config, null, 4)
  );
  res.send("");

  // Create the custom rewards
  rewardsConfig = [];
  await Promise.all(
    customRewardsToCreate.map(async (reward) => {
      const create = await fetch(
        `https://api.twitch.tv/helix/channel_points/custom_rewards?broadcaster_id=510641053`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${account_config.access_token}`,
            "Client-ID": client_config.client_id,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(reward),
        }
      );
      // Fetch error
      if (create.status != 200) {
        console.error("Error", create.status, await create.text());
        return;
      }

      const rewardsData = await create.json();
      // Twitch error
      if (!rewardsData.data) {
        console.error("Error", rewardsData.status, await rewardsData.message);
        return;
      }

      rewardsConfig.push(rewardsData.data[0]);
    })
  );

  console.log(rewardsConfig);
  // Write the ids in config file
  fs.writeFileSync(
    path.join(__dirname, "jsons", "config_rewards.json"),
    JSON.stringify(rewardsConfig, null, 4)
  );
});
app.use(express.static("public"));
server.listen(3000, () => {
  console.log("listening on *:3000");
});
