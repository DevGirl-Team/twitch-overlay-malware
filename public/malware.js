class Malware {
  totalCell = 0;
  nbPhases = 4;
  currentPhase = 0;

  /*
   * the threshold wehre the next palce start to get filled
   * 0 = anywhere from the start
   * 1 = completely filled before continuing
   */
  nextPhaseThreshold = 0.8;
  /*
   * the probality that the old place is filled once the threshold is reached
   */
  probabilityOfOldPhase = 0.5;

  nbRows = 100;
  nbCols = 100;
  cells = [];
  emptyCells = [];
  phasesEmptyCells = [];
  container = null;

  // Computation purposes
  phaseHorizontalWidth = 0;
  phaseVerticalWidth = 0;

  constructor(containerSelector, options) {
    // Hydrate options
    this.nextPhaseThreshold =
      options?.nextPhaseThreshold || this.nextPhaseThreshold;
    this.probabilityOfOldPhase =
      options?.probabilityOfOldPhase || this.probabilityOfOldPhase;

    this.nbRows = options?.nbRows || this.nbRows;
    this.nbCols = options?.nbCols || this.nbCols;
    this.container = document.querySelector(containerSelector);
    this.nbPhases = options?.nbPhases || this.nbPhases;

    this.onEnd = options?.onEnd || null;
  }

  init() {
    this.initGrid();
  }

  reset() {
    this.currentPhase = 0;
    this.totalCell = 0;
    this.container.innerHTML = "";

    this.phaseHorizontalWidth = 0;
    this.phaseVerticalWidth = 0;

    this.cells = [];
    this.emptyCells = [];
    this.phasesEmptyCells = [];

    this.initGrid();
  }

  initGrid() {
    // Largeur document divisé par le nombre de colonnes
    const cellWidth = this.container.offsetWidth / this.nbCols;
    const cellHeight = this.container.offsetHeight / this.nbRows;
    // Création des cellules
    for (let row = 0; row < this.nbCols; row += 1) {
      for (let col = 0; col < this.nbRows; col += 1) {
        this.addCell(cellWidth, cellHeight, row, col);
      }
    }

    this.phaseHorizontalWidth = this.nbCols / (this.nbPhases * 2);
    this.phaseVerticalWidth = this.nbRows / (this.nbPhases * 2);

    for (let i = 0; i < this.nbPhases; i++) {
      const verticalCount =
        (this.nbCols - this.phaseHorizontalWidth * 2 * i) *
        this.phaseVerticalWidth *
        2;
      // +1 on i because we had to remove corner cells already taken in count in vertical count
      const horizontalCount =
        (this.nbRows - this.phaseVerticalWidth * 2 * (i + 1)) *
        this.phaseHorizontalWidth *
        2;
      this.phasesEmptyCells.push(verticalCount + horizontalCount);
    }

    this.emptyCells = this.cells;
  }

  addCell(cellWidth, cellHeight, row, col) {
    const div = document.createElement("div");
    div.style.position = "absolute";
    div.style.width = `${cellWidth}px`;
    div.style.height = `${cellHeight}px`;
    div.style.left = `${cellWidth * row}px`;
    div.style.top = `${cellHeight * col}px`;
    this.container.appendChild(div);
    this.cells.push({ x: row, y: col, el: div });
  }
  getCellPosition() {
    const pos = {
      x: 0,
      y: 0,
    };

    // Get random direction
    // 0 -> Top
    // 1 -> Bottom
    // 2 -> Left
    // 3 -> Right
    const dir = Math.round(Math.random() * 3);

    // Haut && bas
    if (dir === 0 || dir === 1) {
      // Phases don't influence on X
      pos.x = Math.floor(Math.random() * this.nbCols);
      // Get Y depending of the current phase
      pos.y =
        Math.floor(Math.random() * (this.nbRows / (this.nbPhases * 2))) +
        (this.nbRows / (this.nbPhases * 2)) * this.currentPhase;
      // Bas
      if (dir === 1)
        pos.y +=
          this.nbRows -
          this.nbRows / (this.nbPhases * 2) -
          (this.nbCols / (this.nbPhases * 2)) * 2 * this.currentPhase;
    }
    // Gauche && Droite
    else {
      // Phases don't influence on Y
      pos.y = Math.floor(Math.random() * this.nbRows);
      // Get X depending of the current phase
      // (this.nbCols / (this.nbPhases * 2)) -> Get the number/width of a phase for columns.
      // Ex. 8 cols, 4 phases -> 1 column width / phase on the left
      pos.x =
        Math.floor(Math.random() * (this.nbCols / (this.nbPhases * 2))) +
        (this.nbCols / (this.nbPhases * 2)) * this.currentPhase;
      // Droite
      // Move the cell to the right
      // (this.nbCols / (this.nbPhases * 2) * 2 * this.currentPhase) -> Remove the number of cell already taken by the previous phases
      if (dir === 3)
        pos.x +=
          this.nbCols -
          this.nbCols / (this.nbPhases * 2) -
          (this.nbCols / (this.nbPhases * 2)) * 2 * this.currentPhase;
    }

    return pos;
  }
  fillCell() {
    if (this.emptyCells.length === 0) {
      console.info("No more cells");
      return;
    }

    let cell;
    do {
      // If x and y are null, it means random position of the cell
      const pos = this.getCellPosition();

      // Get from the available cells from emptyCells array
      cell = this.emptyCells.find((c) => pos.x === c.x && pos.y === c.y);
    } while (!cell); // Do it until you find an available cell

    if (cell) {
      cell.el.classList.add("filled");
      // Remove the cell from the available cells array
      this.emptyCells = [
        ...this.emptyCells.filter(({ el }) => !el.classList.contains("filled")),
      ];
      if (this.emptyCells.length === 0) {
        this.onEnd();
        return;
      }

      // indicate that a cell has been added to the phase
      this.phasesEmptyCells[this.currentPhase] -= 1;
      // If phase full, go to the next
      if (this.phasesEmptyCells[this.currentPhase] <= 0) {
        this.currentPhase += 1;
      }
    }
  }
}
